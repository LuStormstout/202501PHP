<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>js function</title>
</head>

<body>

    <button id="orderButton" style="width: 200px; height: 50px; background-color: chocolate;">下单</button>

    <script>
        // 什么时候使用函数?
        // 当你需要实现一个功能时, 可以将这个功能封装成一个函数, 这样可以提高代码的复用性, 可读性和可维护性
        // 函数是一段可重复调用的代码块, 可以接受参数, 可以返回值
        // 函数就是方法吗! 做事情的方法, 有输入, 有输出, 有过程

        /**
         * 定义函数
         * 其中 a 和 b 是形式参数(形参)
         * 在实际调用函数时，传递的参数称为实际参数(实参)
         * 
         * @param {number} a
         * @param {number} b
         * @returns {number}
         */
        function add(a, b) {
            return a + b;
        }

        let productList = [
            {
                name: "苹果",
                price: 5
            },
            {
                name: "香蕉",
                price: 3
            },
            {
                name: "橙子",
                price: 4
            }
        ];

        /**
         * 订单函数
         * 
         * @param {Array} productList
         */
        function order(productList) {
            // 判断参数是否是数组
            // 判断是否有库存
            // 判断是否有优惠
            // 计算总价
            // 计算优惠
            // 计算总价
            // 生成订单
            // 保存订单
            // 返回订单号

            // 下单成功与否的依据是什么？
            // 比如说微信支付，支付成功了，微信会异步通知商户，然后返回到我这个方法里面我来判断是否支付成功
            // 比如说商品库存足不足啊? 优惠券是否有效啊? 优惠券是否过期啊? 优惠券是否被使用过啊? 优惠券是否被冻结啊?
            // 等等! 这些都是下单成功与否的依据, 需要做判断, 前端基本上都是依赖于后端返回的结果来判断的

            // 成功了返回 true
            // return true;
            // 失败了返回 false
            return false;
        }

        let orderButton = document.getElementById('orderButton');
        orderButton.addEventListener('click', function () {
            let orderResult = order(productList);
            if (orderResult) {
                alert('下单成功');
            } else {
                alert('下单失败');
            }
        });

        // 调用函数, 并将返回值赋值给变量 sum,这里的 10 和 20 是传递给 add 函数的实际参数
        let sum = add(10, 20); // 调用函数
        console.log(sum); // 30

        // 匿名函数, 也叫函数表达式, 通常用于回调函数, 事件处理函数等, 将函数赋值给变量
        let multiply = function (a, b) {
            return a * b;
        }
        // 调用匿名函数
        console.log(multiply(10, 20)); // 200

        // 箭头函数, 也叫箭头函数表达式, 通常用于回调函数, 事件处理函数等
        let divide = (a, b) => a / b;
        // 调用箭头函数
        console.log(divide(10, 2)); // 5

        // 函数参数
        // 默认参数, 如果调用函数时没有传递参数, 则使用默认参数
        // 在这个例子中, 如果调用 sayHello 函数时没有传递参数, 则使用默认参数 "游客"
        function sayHello(name = "游客") {
            console.log('你好, ' + name + '!');
        }
        sayHello(); // 你好, 游客
        sayHello('张三'); // 你好, 张三

        // 剩余参数, 用于获取函数调用时传递的多余参数
        function sumAll(...args) {
            let sum = 0;
            for (let arg of args) {
                // += 是累加运算符, 等价于 sum = sum + arg
                // -= 是累减运算符, 等价于 sum = sum - arg
                // *= 是累乘运算符, 等价于 sum = sum * arg
                // /= 是累除运算符, 等价于 sum = sum / arg
                // ++ 是自增运算符, 等价于 sum = sum + 1
                // -- 是自减运算符, 等价于 sum = sum - 1
                sum += arg;
            }
            return sum;
        }
        // 调用 sumAll 函数, 传递了 4 个参数, 也可以传递更多参数
        console.log(sumAll(1, 2, 3, 4)); // 10

        // 参数解构
        // 通过解构赋值, 可以将对象或数组中的元素赋值给变量
        // 在这个例子中, 通过解构赋值, 将对象中的属性赋值给变量
        function display({ name, age }) {
            console.log("姓名: " + name);
            console.log("年龄: " + age);
        }

        let person = {
            name: "张三",
            age: 20
        };
        // 调用 display 函数, 传递了一个对象
        display(person);

        // 函数返回值
        // 函数可以返回任意类型的值, 包括数字, 字符串, 布尔值, 对象, 数组, 函数等
        function square(num) {
            // 有返回值的函数, 必须使用 return 语句返回值
            // return num * num;

            // 如果函数没有返回值, 则返回 undefined
        }
        console.log(square(5)); // 25

        // .length 属性, 用于获取字符串、数组、对象等的长度
        let justTestStr = "just test";
        console.log(justTestStr.length); // 9

        // 递归函数
        // 递归函数是指在函数体内调用函数本身
        // 这个例子中, sumArray 函数是一个递归函数, 用于计算数组中所有元素的和
        // 递归函数必须有一个结束条件, 否则会导致无限递归, 最终导致栈溢出
        // 递归函数一般会有两个部分, 一个是基线条件, 一个是递归条件
        // 基线条件是指递归函数的结束条件, 递归条件是指递归函数的调用条件
        // 在这个例子中, 基线条件是数组为空, 递归条件是数组的第一个元素加上剩余部分的和
        // !!! 递归函数的调用过程是一个栈的过程, 每次调用函数时, 会将函数的参数、局部变量等压入栈中
        // !!! 当函数返回时, 会将栈中的数据弹出, 直到栈为空
        // !!! 递归函数的调用次数过多时, 会导致栈溢出, 从而导致程序崩溃
        // !!! 递归函数主要用于解决一些数学问题, 如阶乘、斐波那契数列等「扩展习题用递归函数实现斐波那契数列」
        // !!! 递归函数的效率一般比循环低, 因为递归函数会调用多次函数, 会占用更多的内存
        // 递归函数一般会用在树形结构的数据中, 如 DOM 树、文件系统等, 递归函数可以遍历「树形结构」的数据
        // 属性结构在业务中也很常见, 如部门结构、权限结构等
        /*
        * 部门结构示例:
        *
        *       |--- 经理 ---
        * 老板---
        *       |--- 员工 ---
        *       |
        *       |           |--- 会计 ---
        *       |--- 财务 ---
        *                   |--- 出纳 ---
        * 
        */

        function sumArray(arr) {
            // 如果数组为空，返回0
            if (arr.length === 0) {
                return 0;
            }
            // 取出数组的第一个元素，加上剩余部分的和
            return arr[0] + sumArray(arr.slice(1));
            // 相当于 1 + sumArray([2, 3, 4, 5]) => 1 + 14 = 15, 这个时候 sumArray([2, 3, 4, 5]) 返回 14
            // 相当于 2 + sumArray([3, 4, 5]) => 2 + 12 = 14, 这个时候 sumArray([3, 4, 5]) 返回 12
            // 相当于 3 + sumArray([4, 5]) => 3 + 9 = 12, 这个时候 sumArray([4, 5]) 返回 9
            // 相当于 4 + sumArray([5]) => 4 + 5 = 9, 这个时候 sumArray([5]) 返回 5
            // 相当于 5 + sumArray([]) => 5 + 0 = 5, 这个时候 sumArray([]) 返回 0
            // 执行顺序是从上到下, 从左到右, 返回值是从下到上

            // slice() 方法用于提取数组的一部分, 返回一个新数组, 不会改变原数组
            // slice(start, end) 方法接受两个参数, 第一个参数是开始位置, 第二个参数是结束位置
            // 在第一次执行的时候, arr[0] 是 1, arr.slice(1) 的返回值是 [2, 3, 4, 5]
            // 那么在第二次执行的时候, arr[0] 是 2, arr.slice(1) 的返回值是 [3, 4, 5]
            // 以此类推, 直到 arr.length === 0, 返回 0
        }

        // 测试
        const numbers = [1, 2, 3, 4, 5];
        // console.log(numbers.slice(1)); // 输出：[2, 3, 4, 5]
        console.log(sumArray(numbers)); // 输出：15

        // 闭包
        // 闭包是指函数和函数内部引用的变量构成的组合
        // 闭包可以访问函数内部的变量, 也可以访问函数外部的变量
        // 闭包一般用于封装变量, 避免全局变量的污染「私有化变量」
        // 闭包一般用于回调函数, 事件处理函数等
        function outer() {
            let count = 0;
            return function inner() {
                count++;
                console.log(count);
            };
        }

        let counter = outer();
        counter(); // 输出：1
        counter(); // 输出：2

        console.log(counter); // 输出：[Function: inner]

        // 报错：ReferenceError: count is not defined
        // count 是 outer 函数内部的变量, 在 outer 函数外部无法访问
        console.log(count); 
    </script>
</body>

</html>